<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VisionAssist WebRTC Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: white;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            margin-bottom: 20px;
            padding: 20px;
            background: #2d2d2d;
            border-radius: 8px;
        }
        .video-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        video {
            max-width: 100%;
            border-radius: 8px;
            background: #000;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .status.connected {
            background: #155724;
            border: 1px solid #d4edda;
        }
        .status.disconnected {
            background: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.connecting {
            background: #856404;
            border: 1px solid #ffeaa7;
        }
        .detections {
            background: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .detection-item {
            background: #3d3d3d;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .intent-controls {
            margin: 10px 0;
        }
        select {
            padding: 8px;
            margin: 0 10px;
            background: #3d3d3d;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>VisionAssist WebRTC Client</h1>
        
        <div class="controls">
            <button id="connectBtn">Connect</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
            
            <div class="intent-controls">
                <label for="intentSelect">Intent:</label>
                <select id="intentSelect">
                    <option value="navigate">Navigate</option>
                    <option value="read">Read Text</option>
                    <option value="describe">Describe Scene</option>
                    <option value="identify">Identify Objects</option>
                </select>
                <button id="updateIntentBtn" disabled>Update Intent</button>
            </div>
            
            <div id="status" class="status disconnected">Disconnected</div>
        </div>
        
        <div class="video-container">
            <video id="remoteVideo" autoplay muted controls width="800"></video>
        </div>
        
        <div class="detections">
            <h3>Live Detections</h3>
            <div id="detectionsList">No detections yet...</div>
        </div>
    </div>

    <script>
        class VisionAssistWebRTC {
            constructor() {
                this.peerId = this.generatePeerId();
                this.pc = null;
                this.dataChannel = null;
                this.serverUrl = 'http://localhost:8080';
                
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.updateIntentBtn = document.getElementById('updateIntentBtn');
                this.intentSelect = document.getElementById('intentSelect');
                this.status = document.getElementById('status');
                this.remoteVideo = document.getElementById('remoteVideo');
                this.detectionsList = document.getElementById('detectionsList');
                
                this.setupEventListeners();
            }
            
            generatePeerId() {
                return 'peer_' + Math.random().toString(36).substr(2, 9);
            }
            
            setupEventListeners() {
                this.connectBtn.addEventListener('click', () => this.connect());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.updateIntentBtn.addEventListener('click', () => this.updateIntent());
            }
            
            updateStatus(message, className) {
                this.status.textContent = message;
                this.status.className = `status ${className}`;
            }
            
            async connect() {
                try {
                    this.updateStatus('Connecting...', 'connecting');
                    this.connectBtn.disabled = true;
                    
                    // Create RTCPeerConnection
                    this.pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });
                    
                    // Handle remote stream
                    this.pc.ontrack = (event) => {
                        console.log('Received remote stream');
                        this.remoteVideo.srcObject = event.streams[0];
                    };
                    
                    // Handle ICE candidates
                    this.pc.onicecandidate = async (event) => {
                        if (event.candidate) {
                            console.log('Sending ICE candidate');
                            await this.sendIceCandidate(event.candidate);
                        }
                    };
                    
                    // Handle connection state changes
                    this.pc.onconnectionstatechange = () => {
                        console.log('Connection state:', this.pc.connectionState);
                        if (this.pc.connectionState === 'connected') {
                            this.updateStatus('Connected', 'connected');
                            this.disconnectBtn.disabled = false;
                            this.updateIntentBtn.disabled = false;
                        } else if (this.pc.connectionState === 'failed' || this.pc.connectionState === 'closed') {
                            this.updateStatus('Disconnected', 'disconnected');
                            this.connectBtn.disabled = false;
                            this.disconnectBtn.disabled = true;
                            this.updateIntentBtn.disabled = true;
                        }
                    };
                    
                    // Handle data channel (for receiving detections)
                    this.pc.ondatachannel = (event) => {
                        const channel = event.channel;
                        console.log('Data channel received:', channel.label);
                        
                        channel.onopen = () => {
                            console.log('Data channel opened');
                            this.dataChannel = channel;
                        };
                        
                        channel.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                this.handleDetections(data);
                            } catch (e) {
                                console.error('Error parsing data channel message:', e);
                            }
                        };
                    };
                    
                    // Create offer
                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);
                    
                    // Send offer to server
                    const response = await fetch(`${this.serverUrl}/webrtc/offer`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            peer_id: this.peerId,
                            offer: {
                                sdp: offer.sdp,
                                type: offer.type
                            }
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                    }
                    
                    const result = await response.json();
                    
                    // Set remote description with server's answer
                    await this.pc.setRemoteDescription(new RTCSessionDescription(result.answer));
                    
                    console.log('WebRTC connection established');
                    
                } catch (error) {
                    console.error('Connection error:', error);
                    this.updateStatus(`Connection failed: ${error.message}`, 'disconnected');
                    this.connectBtn.disabled = false;
                }
            }
            
            async sendIceCandidate(candidate) {
                try {
                    await fetch(`${this.serverUrl}/webrtc/ice`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            peer_id: this.peerId,
                            candidate: {
                                candidate: candidate.candidate,
                                sdpMLineIndex: candidate.sdpMLineIndex,
                                sdpMid: candidate.sdpMid
                            }
                        })
                    });
                } catch (error) {
                    console.error('Error sending ICE candidate:', error);
                }
            }
            
            async disconnect() {
                try {
                    if (this.pc) {
                        this.pc.close();
                        this.pc = null;
                    }
                    
                    // Notify server
                    await fetch(`${this.serverUrl}/webrtc/peer/${this.peerId}`, {
                        method: 'DELETE'
                    });
                    
                    this.updateStatus('Disconnected', 'disconnected');
                    this.connectBtn.disabled = false;
                    this.disconnectBtn.disabled = true;
                    this.updateIntentBtn.disabled = true;
                    this.remoteVideo.srcObject = null;
                    this.detectionsList.textContent = 'No detections yet...';
                    
                } catch (error) {
                    console.error('Disconnect error:', error);
                }
            }
            
            async updateIntent() {
                if (!this.dataChannel || this.dataChannel.readyState !== 'open') {
                    console.warn('Data channel not available');
                    return;
                }
                
                const intent = this.intentSelect.value;
                const message = {
                    type: 'intent',
                    intent: intent,
                    timestamp: Date.now() / 1000
                };
                
                try {
                    this.dataChannel.send(JSON.stringify(message));
                    console.log('Intent updated:', intent);
                } catch (error) {
                    console.error('Error updating intent:', error);
                }
            }
            
            handleDetections(data) {
                if (data.type === 'detections' && data.objects) {
                    const detectionsHtml = data.objects.map(obj => {
                        const distance = obj.distance_cm ? ` â€¢ ${obj.distance_cm}cm` : '';
                        return `<div class="detection-item">
                            ${obj.class_name} (${(obj.confidence * 100).toFixed(1)}%)${distance}
                        </div>`;
                    }).join('');
                    
                    this.detectionsList.innerHTML = detectionsHtml || 'No objects detected';
                }
            }
        }
        
        // Initialize the WebRTC client
        const client = new VisionAssistWebRTC();
    </script>
</body>
</html>